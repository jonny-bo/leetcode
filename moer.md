寻找众数 + 摩尔投票法

前置：
1. 数组必须有大于一半的数，否则无效
2. 这个数有且只有一个（一个数组里面不可能同时出现2个及以上大于数组长度一半以上的值）
3. 我们可以把数组抽象为集合，集合分为2个子集[X, Y]. (Y: 数组中出现次数大于数组长度一半的int数值的集合，X: 其他剩余值, A: 数组)
len(X) + len(Y) = len(A);
len(Y) > len(X);

摩尔投票法：可以找出数组A中出现次数大于数组长度一半的int数值

eg: 假设有这样一个场景：票选村长，每人可投一票，我们将候选村长从1开始编号，村民们在票上写上候选村长的编号即可完成投票。
那么最后统计的票可形成一个整型数组。那么谁是村长呢？票数过半的那个人。

思考：[1, 3, 1, 1, 2, 4, 1]
假设第一个投了1号, 那么1号为备选村长，票数为1.
然后第二人投了3号，此时1号备选失去资格，重新竞选（3号和1号票数相同，1号票数没有过半）.
第三人投的1号继续获得备选资格票数1
第四人也投了1号票数为2.
第五六人没有投1号，失去备选资格（1票数没有过半），重新竞选。
第七人投了1号，1号获取备选资格1票，投票结束，1号票数过半胜利（没有竞争对手）。

至于为什么第五六人没有投1号，1号，2号，4号会同事失去备选资格，他们并没有投同一个人，讲道理1号2号4号比分应该是2:1:1。
注意：投票规则是，票数必须过半而不是票数最多，而投票数过半的最多只会存在一个人，题目假设这个人x存在。

即：我们把集合拆成两个子集：X, Y
也就是投票分批次统计，总条件：len(X) + len(Y) = len(A);

已知：A中必存在一组子集Y, 满足 len(Y) > len(X); len(Y) - len(X) > 0

所以，我们把[1, 3, 1, 1, 2, 4, 1]中第一个当成备选Y且len(Y) = 1，遇到X则len(Y)减去1。
如果统计结束前len(Y) = 0，则重新进行竞选（之前的len(X) = len(Y)），因为结束前必然存在一组len(Y) > len(X)。即结束的时候必然存在len(Y) > 0

leecode题目：

```
给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数
```

c语言题解：

```c
int majorityElement(int* nums, int numsSize) {
    int res = nums[0], count = 1;
    for (int i = 1; i < numsSize; i++)
    {
        if (count == 0)
        {
            res = nums[i];
            count = 1;
        } else {
            if (res == nums[i]) {
                count ++;
            } else {
                count --;
            }
        }
    }
    
    return res;
}
```